<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>markdown.lua</title>
    <link rel="stylesheet" type="text/css" href="default.css" />
    <script>document.write('<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/'+(matchMedia('(prefers-color-scheme:dark)').matches?'github-dark':'github')+'.min.css"/>')</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
<div class="container">
<nav class="sidebar">
<h2>Contents <a href="index.html" class="sidebar-home" title="Home">⌂</a></h2>
<ul id="toc">
<li><a href="#chk">Checks</a></li>
<li class="toc-sub"><a href="#chk-1">1. Lua 5.1/5.2 compatibility</a></li>
<li class="toc-sub"><a href="#chk-2">2. Returns true if line is a ruler of repeated characters</a></li>
<li class="toc-sub"><a href="#chk-3">3. Classify block-level formatting in a line</a></li>
<li class="toc-sub"><a href="#chk-4">4. Returns target="_blank" attribute for external URLs</a></li>
<li><a href="#def">Defines</a></li>
<li class="toc-sub"><a href="#def-1">1. Forward declarations for mutually recursive functions</a></li>
<li class="toc-sub"><a href="#def-2">2. Map values in table through function f</a></li>
<li class="toc-sub"><a href="#def-3">3. Identity function, useful as a placeholder</a></li>
<li class="toc-sub"><a href="#def-4">4. Functional style ternary (no short circuit)</a></li>
<li class="toc-sub"><a href="#def-5">5. Hash data into unique alphanumeric strings</a></li>
<li class="toc-sub"><a href="#def-6">6. Protect document parts from modification</a></li>
<li class="toc-sub"><a href="#def-7">7. Characters with special markdown meaning needing escape</a></li>
<li><a href="#run">Runners</a></li>
<li class="toc-sub"><a href="#run-1">1. Split text into array of lines by separator</a></li>
<li class="toc-sub"><a href="#run-2">2. Block-level text transforms working with arrays of lines</a></li>
<li class="toc-sub"><a href="#run-3">3. Convert normal + ruler lines to header entries</a></li>
<li class="toc-sub"><a href="#run-4">4. Convert list blocks to protected HTML</a></li>
<li class="toc-sub"><a href="#run-5">5. Convert blockquote markers with GitHub callout support</a></li>
<li class="toc-sub"><a href="#run-6">6. Convert fenced code blocks with language hints</a></li>
<li class="toc-sub"><a href="#run-7">7. Span-level text transforms for inline formatting</a></li>
<li class="toc-sub"><a href="#run-8">8. Normalize line endings, tabs, and whitespace</a></li>
<li class="toc-sub"><a href="#run-9">9. Main markdown processing pipeline</a></li>
<li class="toc-sub"><a href="#run-10">10. CLI handler with HTML wrapping and TOC generation</a></li>
<li><a href="#err">Errors</a></li>
</ul>
</nav>
<main class="content">

<h1>markdown.lua</h1>

<p><code>~/Desktop/autoodocs/markdown.lua</code></p>

<p>Markdown to HTML converter with GitHub-style callouts and TOC generation</p>

<p>Mostly stolen from <em>↗ <a href="https://github.com/speedata/luamarkdown" target="_blank">speedata</a></em> with minor modifications for parsers/build.</p>

<h2><a id="chk"></a>Checks</h2>

<h3><a id="chk-1"></a>1. Lua 5.1/5.2 compatibility</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:69</code></p>

<pre><code class="language-lua">table.unpack = table.unpack or unpack
</code></pre>

<h3><a id="chk-2"></a>2. Returns true if line is a ruler of repeated characters</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:338</code></p>

<p>The line must contain at least three char characters and contain only spaces and</p>

<blockquote>
    <p>char characters.</p>
</blockquote>

<pre><code class="language-lua">local function is_ruler_of(line, char)
    if not line:match("^[ %" .. char .. "]*$") then return false end
    if not line:match("%" .. char .. ".*%" .. char .. ".*%" .. char) then return false end
    return true
end
</code></pre>

<h3><a id="chk-3"></a>3. Classify block-level formatting in a line</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:347</code></p>

<pre><code class="language-lua">local function classify(line)
    local info = {line = line, text = line}

    if line:match("^    ") then
        info.type = "indented"
        info.outdented = line:sub(5)
        return info
    end

    for _,c in ipairs({'*', '-', '_', '='}) do
        if is_ruler_of(line, c) then
            info.type = "ruler"
            info.ruler_char = c
            return info
        end
    end

    if line == "" then
        info.type = "blank"
        return info
    end

    if line:match("^(#+)[ \t]*(.-)[ \t]*#*[ \t]*$") then
        local m1, m2 = line:match("^(#+)[ \t]*(.-)[ \t]*#*[ \t]*$")
        info.type = "header"
        info.level = m1:len()
        info.text = m2
        return info
    end

    if line:match("^ ? ? ?(%d+)%.[ \t]+(.+)") then
        local number, text = line:match("^ ? ? ?(%d+)%.[ \t]+(.+)")
        info.type = "list_item"
        info.list_type = "numeric"
        info.number = 0 + number
        info.text = text
        return info
    end

    if line:match("^ ? ? ?([%*%+%-])[ \t]+(.+)") then
        local bullet, text = line:match("^ ? ? ?([%*%+%-])[ \t]+(.+)")
        info.type = "list_item"
        info.list_type = "bullet"
        info.bullet = bullet
        info.text= text
        return info
    end

    if line:match("^&gt;[ \t]?(.*)") then
        info.type = "blockquote"
        info.text = line:match("^&gt;[ \t]?(.*)")
        return info
    end

    if is_protected(line) then
        info.type = "raw"
        info.html = unprotect(line)
        return info
    end

    info.type = "normal"
    return info
end
</code></pre>

<h3><a id="chk-4"></a>4. Returns target="_blank" attribute for external URLs</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:922</code></p>

<pre><code class="language-lua">local function external(url)
    if url:match("^https?://") or url:match("^ftp:") then return ' target="_blank"' end
    return ""
end
</code></pre>

<h2><a id="def"></a>Defines</h2>

<h3><a id="def-1"></a>1. Forward declarations for mutually recursive functions</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:72</code></p>

<pre><code class="language-lua">local span_transform, encode_backslash_escapes, block_transform, blocks_to_html
</code></pre>

<h3><a id="def-2"></a>2. Map values in table through function f</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:79</code></p>

<pre><code class="language-lua">local function map(t, f)
    local out = {}
    for k,v in pairs(t) do out[k] = f(v,k) end
    return out
end
</code></pre>

<h3><a id="def-3"></a>3. Identity function, useful as a placeholder</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:86</code></p>

<pre><code class="language-lua">local function identity(text) return text end
</code></pre>

<h3><a id="def-4"></a>4. Functional style ternary (no short circuit)</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:89</code></p>

<pre><code class="language-lua">local function iff(t, a, b) if t then return a else return b end end
</code></pre>

<h3><a id="def-5"></a>5. Hash data into unique alphanumeric strings</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:203</code></p>

<div class="callout callout-note">
    <div class="callout-title">NOTE</div>
    <p>not cryptographic - used to protect parts from further processing</p>
</div>

<pre><code class="language-lua">local HASH = {
    -- Has the hash been inited.
    inited = false,

    -- The unique string prepended to all hash values. This is to ensure
    -- that hash values do not accidently coincide with an actual existing
    -- string in the document.
    identifier = "",

    -- Counter that counts up for each new hash instance.
    counter = 0,

    -- Hash table.
    table = {}
}
</code></pre>

<h3><a id="def-6"></a>6. Protect document parts from modification</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:255</code></p>

<div class="callout callout-note">
    <div class="callout-title">NOTE</div>
    <p>saved in table for later unprotection</p>
</div>

<pre><code class="language-lua">local PD = {
    -- Saved blocks that have been converted
    blocks = {},

    -- Block level tags that will be protected
    tags = {"p", "div", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote",
    "pre", "table", "dl", "ol", "ul", "script", "noscript", "form", "fieldset",
    "iframe", "math", "ins", "del"}
}
</code></pre>

<h3><a id="def-7"></a>7. Characters with special markdown meaning needing escape</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:778</code></p>

<pre><code class="language-lua">escape_chars = "'\\`*_{}[]()&gt;#+-.!'"
escape_table = {}
</code></pre>

<h2><a id="run"></a>Runners</h2>

<h3><a id="run-1"></a>1. Split text into array of lines by separator</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:92</code></p>

<pre><code class="language-lua">local function split(text, sep)
    sep = sep or "\n"
    local lines = {}
    local pos = 1
    while true do
        local b,e = text:find(sep, pos)
        if not b then table.insert(lines, text:sub(pos)) break end
        table.insert(lines, text:sub(pos, b-1))
        pos = e + 1
    end
    return lines
end
</code></pre>

<h3><a id="run-2"></a>2. Block-level text transforms working with arrays of lines</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:336</code></p>


<h3><a id="run-3"></a>3. Convert normal + ruler lines to header entries</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:412</code></p>

<pre><code class="language-lua">local function headers(array)
    local i = 1
    while i &lt;= #array - 1 do
        if array[i].type  == "normal" and array[i+1].type == "ruler" and
            (array[i+1].ruler_char == "-" or array[i+1].ruler_char == "=") then
            local info = {line = array[i].line}
            info.text = info.line
            info.type = "header"
            info.level = iff(array[i+1].ruler_char == "=", 1, 2)
            table.remove(array, i+1)
            array[i] = info
        end
        i = i + 1
    end
    return array
end
</code></pre>

<h3><a id="run-4"></a>4. Convert list blocks to protected HTML</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:430</code></p>

<pre><code class="language-lua">local function lists(array, sublist)
    local function process_list(arr)
        local function any_blanks(arr)
            for i = 1, #arr do
                if arr[i].type == "blank" then return true end
            end
            return false
        end

        local function split_list_items(arr)
            local acc = {arr[1]}
            local res = {}
            for i=2,#arr do
                if arr[i].type == "list_item" then
                    table.insert(res, acc)
                    acc = {arr[i]}
                else
                    table.insert(acc, arr[i])
                end
            end
            table.insert(res, acc)
            return res
        end

        local function process_list_item(lines, block)
            while lines[#lines].type == "blank" do
                table.remove(lines)
            end

            local itemtext = lines[1].text
            for i=2,#lines do
                itemtext = itemtext .. "\n" .. outdent(lines[i].line)
            end
            if block then
                itemtext = block_transform(itemtext, true)
                if not itemtext:find("&lt;pre&gt;") then itemtext = indent(itemtext) end
                return "    &lt;li&gt;" .. itemtext .. "&lt;/li&gt;"
            else
                local lines = split(itemtext)
                lines = map(lines, classify)
                lines = lists(lines, true)
                lines = blocks_to_html(lines, true)
                itemtext = table.concat(lines, "\n")
                if not itemtext:find("&lt;pre&gt;") then itemtext = indent(itemtext) end
                return "    &lt;li&gt;" .. itemtext .. "&lt;/li&gt;"
            end
        end

        local block_list = any_blanks(arr)
        local items = split_list_items(arr)
        local out = ""
        for _, item in ipairs(items) do
            out = out .. process_list_item(item, block_list) .. "\n"
        end
        if arr[1].list_type == "numeric" then
            return "&lt;ol&gt;\n" .. out .. "&lt;/ol&gt;"
        else
            return "&lt;ul&gt;\n" .. out .. "&lt;/ul&gt;"
        end
    end

    -- Finds the range of lines composing the first list in the array. A list
    -- starts with (^ list_item) or (blank list_item) and ends with
    -- (blank* $) or (blank normal).
    --
    -- A sublist can start with just (list_item) does not need a blank...
    local function find_list(array, sublist)
        local function find_list_start(array, sublist)
            if array[1].type == "list_item" then return 1 end
            if sublist then
                for i = 1,#array do
                    if array[i].type == "list_item" then return i end
                end
            else
                for i = 1, #array-1 do
                    if array[i].type == "blank" and array[i+1].type == "list_item" then
                        return i+1
                    end
                end
            end
            return nil
        end
        local function find_list_end(array, start)
            local pos = #array
            for i = start, #array-1 do
                if array[i].type == "blank" and array[i+1].type ~= "list_item"
                    and array[i+1].type ~= "indented" and array[i+1].type ~= "blank" then
                    pos = i-1
                    break
                end
            end
            while pos &gt; start and array[pos].type == "blank" do
                pos = pos - 1
            end
            return pos
        end

        local start = find_list_start(array, sublist)
        if not start then return nil end
        return start, find_list_end(array, start)
    end

    while true do
        local start, stop = find_list(array, sublist)
        if not start then break end
        local text = process_list(splice(array, start, stop))
        local info = {
            line = text,
            type = "raw",
            html = text
        }
        array = splice(array, start, stop, {info})
    end

    -- Convert any remaining list items to normal
    for _,line in ipairs(array) do
        if line.type == "list_item" then line.type = "normal" end
    end

    return array
end
</code></pre>

<h3><a id="run-5"></a>5. Convert blockquote markers with GitHub callout support</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:553</code></p>

<pre><code class="language-lua">local function blockquotes(lines)
    local function find_blockquote(lines)
        local start
        for i,line in ipairs(lines) do
            if line.type == "blockquote" then
                start = i
                break
            end
        end
        if not start then return nil end

        local stop = #lines
        for i = start+1, #lines do
            if lines[i].type == "blank" or lines[i].type == "blockquote" then
            elseif lines[i].type == "normal" then
                if lines[i-1].type == "blank" then stop = i-1 break end
            else
                stop = i-1 break
            end
        end
        while lines[stop].type == "blank" do stop = stop - 1 end
        return start, stop
    end

    local function process_blockquote(lines)
        local raw = lines[1].text
        for i = 2,#lines do
            raw = raw .. "\n" .. lines[i].text
        end

        -- Check for GitHub-style callouts [!NOTE], [!TIP], [!IMPORTANT], [!WARNING], [!CAUTION]
        local callout_type = raw:match("^%[!(%u+)%]")
        if callout_type then
            raw = raw:gsub("^%[!%u+%]%s*", "") -- remove the callout marker
            local bt = block_transform(raw)
            if not bt:find("&lt;pre&gt;") then bt = indent(bt) end
            local ctype = callout_type:lower()
            return '&lt;div class="callout callout-' .. ctype .. '"&gt;\n    &lt;div class="callout-title"&gt;' ..
                callout_type .. '&lt;/div&gt;\n    ' .. bt .. "\n&lt;/div&gt;"
        end

        local bt = block_transform(raw)
        if not bt:find("&lt;pre&gt;") then bt = indent(bt) end
        return "&lt;blockquote&gt;\n    " .. bt ..
            "\n&lt;/blockquote&gt;"
    end

    while true do
        local start, stop = find_blockquote(lines)
        if not start then break end
        local text = process_blockquote(splice(lines, start, stop))
        local info = {
            line = text,
            type = "raw",
            html = text
        }
        lines = splice(lines, start, stop, {info})
    end
    return lines
end
</code></pre>

<h3><a id="run-6"></a>6. Convert fenced code blocks with language hints</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:615</code></p>

<pre><code class="language-lua">local function fenced_codeblocks(lines)
    local function find_fenced_codeblock(lines)
        local start, fence_char, fence_len, lang
        for i, line in ipairs(lines) do
            local fc, rest = line.line:match("^(```+)(.*)")
            if not fc then
                fc, rest = line.line:match("^(~~~+)(.*)")
            end
            if fc then
                start = i
                fence_char = fc:sub(1,1)
                fence_len = #fc
                lang = rest:match("^%s*(%S*)") or ""
                break
            end
        end
        if not start then return nil end

        -- Find closing fence (must be at least as long, same char, nothing else on line)
        local stop
        for i = start + 1, #lines do
            local fc = lines[i].line:match("^(" .. fence_char:rep(fence_len) .. "+)%s*$")
            if fc then
                stop = i
                break
            end
        end
        if not stop then return nil end
        return start, stop, lang
    end

    local function process_fenced_codeblock(lines, start, stop, lang)
        local code_lines = {}
        for i = start + 1, stop - 1 do
            table.insert(code_lines, detab(encode_code(lines[i].line)))
        end
        local raw = table.concat(code_lines, "\n")
        if lang and lang ~= "" then
            return '&lt;pre&gt;&lt;code class="language-' .. lang .. '"&gt;' .. raw .. "\n&lt;/code&gt;&lt;/pre&gt;"
        else
            return "&lt;pre&gt;&lt;code&gt;" .. raw .. "\n&lt;/code&gt;&lt;/pre&gt;"
        end
    end

    while true do
        local start, stop, lang = find_fenced_codeblock(lines)
        if not start then break end
        local text = process_fenced_codeblock(lines, start, stop, lang)
        local info = {
            line = text,
            type = "raw",
            html = text
        }
        lines = splice(lines, start, stop, {info})
    end
    return lines
end
</code></pre>

<h3><a id="run-7"></a>7. Span-level text transforms for inline formatting</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:776</code></p>


<h3><a id="run-8"></a>8. Normalize line endings, tabs, and whitespace</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:1078</code></p>

<pre><code class="language-lua">local function cleanup(text)
    -- Standardize line endings
    text = text:gsub("\r\n", "\n")  -- DOS to UNIX
    text = text:gsub("\r", "\n")    -- Mac to UNIX

    -- Convert all tabs to spaces
    text = detab(text)

    -- Strip lines with only spaces and tabs
    while true do
        local subs
        text, subs = text:gsub("\n[ \t]+\n", "\n\n")
        if subs == 0 then break end
    end

    return "\n" .. text .. "\n"
end
</code></pre>

<h3><a id="run-9"></a>9. Main markdown processing pipeline</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:1123</code></p>

<pre><code class="language-lua">local function markdown(text)
    init_hash(text)
    init_escape_table()

    text = cleanup(text)
    text = protect(text)
    text, link_database = strip_link_definitions(text)
    text = block_transform(text)
    text = unescape_special_chars(text)
    return text
end
</code></pre>

<h3><a id="run-10"></a>10. CLI handler with HTML wrapping and TOC generation</h3>

<p><code>~/Desktop/autoodocs/markdown.lua:1226</code></p>

<pre><code class="language-lua">local function run_command_line(arg)
</code></pre>

<h2><a id="err"></a>Errors</h2>

<p><a id="err-1"></a><strong>1. ~/Desktop/autoodocs/markdown.lua:1233</strong>
<em>↳ <a href="#run-10">@run 10.</a></em></p>

<p>Header file not found</p>

<pre><code class="language-lua">        if options.header then
</code></pre>

<p><a id="err-1-1"></a><strong>1.1 ~/Desktop/autoodocs/markdown.lua:1260</strong>
<em>↳ <a href="#err-1">@err 1.</a></em></p>

<p>Stylesheet file not found for inline inclusion</p>

<pre><code class="language-lua">            if options.inline_style then
</code></pre>

<p><a id="err-2"></a><strong>2. ~/Desktop/autoodocs/markdown.lua:1351</strong>
<em>↳ <a href="#run-10">@run 10.</a></em></p>

<p>Footer file not found</p>

<pre><code class="language-lua">        if options.footer then
</code></pre>

<p><a id="err-3"></a><strong>3. ~/Desktop/autoodocs/markdown.lua:1424</strong>
<em>↳ <a href="#run-10">@run 10.</a></em></p>

<p>Test file not found</p>

<pre><code class="language-lua">        local f = io.open(n)
</code></pre>

<p><a id="err-4"></a><strong>4. ~/Desktop/autoodocs/markdown.lua:1434</strong>
<em>↳ <a href="#run-10">@run 10.</a></em></p>

<p>Input or output file cannot be opened</p>

<pre><code class="language-lua">    op:arg(function(path)
</code></pre>


<div class="build-timestamp">Generated: 2026-02-15 23:18</div>
</main>
</div>
<script>
hljs.highlightAll();
// Hide home icon on index page
if (location.pathname.endsWith('index.html') || location.pathname.endsWith('/')) {
    var home = document.querySelector('.sidebar-home');
    if (home) home.style.display = 'none';
}
// Highlight active section on scroll
var links = document.querySelectorAll('.sidebar a');
var sections = document.querySelectorAll('.content h2, .content h3');
window.addEventListener('scroll', function() {
    var current = '';
    sections.forEach(function(section) {
        var anchor = section.querySelector('a');
        if (anchor && window.scrollY >= section.offsetTop - 100) {
            current = anchor.id;
        }
    });
    links.forEach(function(link) {
        link.classList.remove('active');
        if (link.getAttribute('href') === '#' + current) {
            link.classList.add('active');
        }
    });
});
</script>
</body></html>